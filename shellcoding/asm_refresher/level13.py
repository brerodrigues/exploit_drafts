import glob
from pwn import *

"""
https://www.cs.virginia.edu/~evans/cs216/guides/x86.html

Recall that memory is stored linearly. What does that mean? Say we access the quad word at 0x1337:
[0x1337] = 0x00000000deadbeef The real way memory is layed out is byte by byte, little endian:
[0x1337] = 0xef
[0x1337 + 1] = 0xbe
[0x1337 + 2] = 0xad
...
[0x1337 + 7] = 0x00
What does this do for us? Well, it means that we can access things next to each other using offsets,
like what was shown above. Say you want the 5th *byte* from an address, you can access it like:
mov al, [address+4]
Remember, offsets start at 0.

Preform the following:
1. load two consecutive quad words from the address stored in rdi
2. calculate the sum of the previous steps quad words.
3. store the sum at the address in rsi

We will now set the following in preparation for your code:
[0x4041c0] = 0x000000000005F22D
[0x4046e8] = 0x0000000000080E15
rdi = 0x4041c0
rsi = 0x4046e8
"""

context.arch = "x86_64"
#context.log_level = "DEBUG"

# pwntools will change SYS_exit to the respective syscall
assembly = """
    movq rcx, [rdi]
    movq rax, [rdi + 8]
    add rcx, rax
    movq [rsi], rcx
"""

shellcode = asm(assembly)
#print(disasm(shellcode))

#p = process(['/challenge/embryoasm_level6', 'DEBUG'])
p = process(['/challenge/embryoasm_level13'])
print(p.recv(timeout=2).decode())
p.send(shellcode)
print(p.interactive())