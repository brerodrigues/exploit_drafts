import glob
from pwn import *

"""
It is worth noting, as you may have noticed, that values are stored in reverse order of how we
represent them. As an example, say:
[0x1330] = 0x00000000deadc0de
If you examined how it actually looked in memory, you would see:
[0x1330] = 0xde 0xc0 0xad 0xde 0x00 0x00 0x00 0x00
This format of storing things in 'reverse' is intentional in x86, and its called Little Endian.

For this challenge we will give you two addresses created dynamically each run. The first address
will be placed in rdi. The second will be placed in rsi.
Using the earlier mentioned info, perform the following:
1. set [rdi] = 0xDEADBEEF00001337
2. set [rsi] = 0x000000C0FFEE0000
Hint: it may require some tricks to assign a big constant to a dereferenced register. Try setting
a register to the constant than assigning that register to the derefed register.

We will now set the following in preparation for your code:
[0x404198] = 0xffffffffffffffff
[0x404888] = 0xffffffffffffffff
rdi = 0x404198
rsi = 0x404888

mov <reg>,<reg>
mov <reg>,<mem>
mov <mem>,<reg>
mov <reg>,<const>
mov <mem>,<const>
"""

context.arch = "x86_64"
#context.log_level = "DEBUG"

# pwntools will change SYS_exit to the respective syscall
assembly = """
    mov rcx, 0xDEADBEEF00001337
    mov [rdi], rcx
    mov rcx, 0x000000C0FFEE0000
    mov [rsi], rcx
"""

shellcode = asm(assembly)
#print(disasm(shellcode))

#p = process(['/challenge/embryoasm_level6', 'DEBUG'])
p = process(['/challenge/embryoasm_level12'])
print(p.recv(timeout=2).decode())
p.send(shellcode)
print(p.interactive())
