import glob
from pwn import *

"""
In this level you will be working with memory. This will require you to read or write
to things stored linearly in memory. If you are confused, go look at the linear
addressing module in 'ike. You may also be asked to dereference things, possibly multiple
times, to things we dynamically put in memory for you use.

Up until now you have worked with registers as the only way for storing things, essentially
variables like 'x' in math. Recall that memory can be addressed. Each address contains something
at that location, like real addresses! As an example: the address '699 S Mill Ave, Tempe, AZ 85281'
maps to the 'ASU Campus'. We would also say it points to 'ASU Campus'.  We can represent this like:
['699 S Mill Ave, Tempe, AZ 85281'] = 'ASU Campus'
The address is special because it is unique. But that also does not mean other address cant point to
the same thing (as someone can have multiple houses). Memory is exactly the same! For instance,the address in memory that your code is stored (when we take it from you) is 0x400000.
In x86 we can access the thing at a memory location, called dereferencing, like so:
mov rax, [some_address]        <=>     Moves the thing at 'some_address' into rax
This also works with things in registers:
mov rax, [rdi]         <=>     Moves the thing stored at the address of what rdi holds to rax
This works the same for writing:
mov [rax], rdi         <=>     Moves rdi to the address of what rax holds.
So if rax was 0xdeadbeef, then rdi would get stored at the address 0xdeadbeef:
[0xdeadbeef] = rdi
Note: memory is linear, and in x86, it goes from 0 - 0xffffffffffffffff (yes, huge).

Please perform the following:
1. Place the value stored at 0x404000 into rax
2. Increment the value stored at the address 0x404000 by 0x1337
Make sure the value in rax is the original value stored at 0x404000 and make sure
that [0x404000] now has the incremented value.

We will now set the following in preparation for your code:
[0x404000] = 0x1c8724

ADD
add <reg>,<reg>
add <reg>,<mem>
add <mem>,<reg>
add <reg>,<con>
add <mem>,<con>
"""

context.arch = "x86_64"
#context.log_level = "DEBUG"

# pwntools will change SYS_exit to the respective syscall
assembly = """
    mov rax, [0x404000]
    add 0x404000, 0x1337
"""
shellcode = asm(assembly)
#print(disasm(shellcode))

#p = process(['/challenge/embryoasm_level6', 'DEBUG'])
p = process(['/challenge/embryoasm_level10'])
print(p.recv(timeout=2).decode())
p.send(shellcode)
print(p.interactive())
