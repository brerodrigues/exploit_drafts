import glob
from pwn import *

"""
https://www.cs.virginia.edu/~evans/cs216/guides/x86.html

Without using pop please calculate the average of 4 consecutive quad words stored on the stack.
Store the average on the top of the stack. Hint:
RSP+0x?? Quad Word A
RSP+0x?? Quad Word B
RSP+0x?? Quad Word C
RSP      Quad Word D
RSP-0x?? Average

We will now set the following in preparation for your code:
(stack) [0x7fffff200000:0x7fffff1fffe0] = ['0x66a0c99', '0xdc67676', '0x22ec2915', '0x22a38f38'] (list of things)

mov rax, reg1; 
div reg2 

Notice: to use this instruction you need to first load rax with the desired register
you intended to be the divided. Then run div reg2, where reg2 is the divisor. This
results in:
rax = rdi / rsi; rdx = remainder
The quotient is placed in rax, the remainder is placed in rdx.
"""

context.arch = "amd64"
#context.log_level = "DEBUG"

# rdi / rsi -> put rdi in rax, div rsi, resultado estara em rax, resto estara em rdx
# pwntools will change SYS_exit to the respective syscall


context.arch = "x86_64"
#context.log_level = "DEBUG"

# pwntools will change SYS_exit to the respective syscall
assembly = """
    mov rdi, 4

    mov rax, [rsp]
    div rdi
    mov ecx, eax

    mov rax, [rsp+8]
    div rdi
    mov ebx, eax

    mov rax, [rsp+16]
    div rdi
    mov edx, eax

    TA ESTOURANDO UM ERRO NESSA DIVISAO E EU N SEI PQ...
    mov rax, [rsp+24]
    div rdi
    mov edi, eax

    xor rax, rax
    add eax, ecx
    add eax, ebx
    add eax, edx
    add eax, edi
    
    push rax
"""

shellcode = asm(assembly)
#print(disasm(shellcode))

p = process(['/challenge/embryoasm_level16'])
print(p.recv(timeout=2).decode())
p.send(shellcode)
print(p.interactive())