# 7 chall
def hex_list_to_str(list_hex):
    string_key = ''
    
    for hex_value in list_hex:
        string_key = string_key + chr(int(hex_value, 16))
    
    #print (string_key[::-1])
    return string_key
    
def crack_key(list_hex):
    key = []

    # change positions of predefined bytes
    setimo = list_hex[7]
    decimo = list_hex[10]
    list_hex[7] = decimo
    list_hex[10] = setimo
    
    # magic xor
    for idx, hex_value in enumerate(list_hex):
        decisions = idx % 3

        if decisions == 2:
            key.append(hex((hex_value^0x93)))
        elif decisions == 0:
            key.append(hex((hex_value^0x98)))
        elif decisions == 1:
            key.append(hex((hex_value^0x51)))
        else:
            print('should never happen')
        
        # the original is taken from assembly and pseudocode in a sleepy friday night
        # so, is shit code but i kept here for historical reasons (:
        #if decisions == 2:
        #    key.append(hex((hex_value^0x93)))
        #elif decisions == 0:
        #    if decisions < 3:
        #        if decisions == 0:
        #            key.append(hex((hex_value^0x98)))
        #        else:
        #            if decisions == 1:
        #                key.append(hex((hex_value^0x51)))
            
    return key

encoded_key = [0xf5,0x30,0xfe,0xff,0x3b,0xfa,0xff,0x34,0xf0,0xea,0x2b,0xe2]
            # [0xf5,0x30,0xfe,0xff,0x3b,0xfa,0xff,0x2b,0xf0,0xea,0x34,0xe2] aqui q descobri q trocam o 7 pelo 10
cracked_key_hex = crack_key(encoded_key)
decoded_key = hex_list_to_str(cracked_key_hex)
print (decoded_key[::-1]) # revert the string to get the right key
